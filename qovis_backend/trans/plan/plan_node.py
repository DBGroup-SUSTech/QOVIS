from typing import Optional, Type, Any

from trans.common.tree_node import TreeNode
from trans.plan.param.attribute import Attribute
from trans.plan.param.attributes import Attributes
from trans.plan.param.base_param import BaseParam
from trans.plan.param.expressions import Expressions
from trans.plan.param.predicate import Predicate
from trans.plan.param.relation import Relation
from trans.plan.param.str_param import StrParam
from utils.id_counter import IdCounter


class PlanNode(TreeNode):
    def __init__(self):
        super().__init__()
        self.name: str = 'UnKnown'
        self.n_child: int = 0       # number of children must equal to the number of rel params, unless the leave node

        self.plan: 'Plan' = None
        self.vid: int = 0
        self.clazz: str = 'UnKnown'
        self.str_: str = ''
        self.addr: int = 0

        self.params: dict[BaseParam.Kind, list[BaseParam]] = {}
        self.required_params: set[BaseParam] = set()

        self.children: list[PlanNode] = []

        # pattern matching
        self.exclusions: set[type[PlanNode]] = set()
        self.bound_src: Optional['PlanNode'] = None

    def _add_attrs(self, value: Attribute = None, required: bool = True) -> Attributes:
        ret = self._add_param(BaseParam.Kind.ATTRS, value, required)
        assert isinstance(ret, Attributes)
        return ret

    def _add_pred(self, value: Predicate = None, required: bool = True) -> Predicate:
        ret = self._add_param(BaseParam.Kind.PRED, value, required)
        assert isinstance(ret, Predicate)
        return ret

    def _add_rel(self, value: Relation = None, required: bool = True) -> Relation:
        ret = self._add_param(BaseParam.Kind.REL, value, required)
        assert isinstance(ret, Relation)
        return ret

    def _add_exprs(self, value: Expressions = None, required: bool = True) -> Expressions:
        ret = self._add_param(BaseParam.Kind.EXPRS, value, required)
        assert isinstance(ret, Expressions)
        return ret

    def _add_str(self, value: str = None, required: bool = True) -> StrParam:
        ret = self._add_param(BaseParam.Kind.STR, value, required)
        assert isinstance(ret, StrParam)
        return ret

    # deprecated
    def _add_other(self, value: BaseParam = None, required: bool = True) -> BaseParam:
        ret = self._add_param(BaseParam.Kind.OTHER, value, required)
        assert isinstance(ret, BaseParam)
        return ret

    def _add_param(self, kind: BaseParam.Kind, value: BaseParam = None, required: bool = True) -> BaseParam:
        if kind == BaseParam.Kind.ATTRS:
            if value is None:
                value = Attributes()
            assert isinstance(value, Attributes)
        elif kind == BaseParam.Kind.PRED:
            if value is None:
                value = Predicate()
            assert isinstance(value, Predicate)
        elif kind == BaseParam.Kind.REL:
            if value is None:
                value = Relation()
            assert isinstance(value, Relation)
        elif kind == BaseParam.Kind.EXPRS:
            if value is None:
                value = Expressions()
            assert isinstance(value, Expressions)
        elif kind == BaseParam.Kind.STR:
            if value is None:
                value = StrParam()
            assert isinstance(value, StrParam)
        elif kind == BaseParam.Kind.OTHER:
            assert isinstance(value, BaseParam)
        else:
            raise ValueError(f"Unknown param kind: {kind}")

        self.params.setdefault(kind, []).append(value)
        value.set_owner(self)

        if required:
            self.required_params.add(value)

        return value

    def is_param_required(self, param: BaseParam) -> bool:
        return param in self.required_params

    @property
    def output(self) -> Attributes:
        if not self.is_concrete():
            return Attributes().init([]).as_output(self)
        output_rel = self.compute_output_rel()
        return output_rel.attrs.as_output(self)

    def assign(self, plan: 'Plan', vid: int, clazz: str, str_: str, addr: int):
        self.plan = plan
        self.vid = vid
        self.clazz = clazz
        self.str_ = str_
        self.addr = addr

    def assign_from(self, other: 'PlanNode'):
        self.assign(other.plan, other.vid, other.clazz, other.str_, other.addr)

    def init(self):
        raise NotImplementedError

    def complete_param_and_check(self):
        raise NotImplementedError

    def compute_output_rel(self) -> Relation:
        raise NotImplementedError

    def backtrace_attr(self, attr: Attribute) -> Attribute:
        """
        If an attribute is generated by this operation, return the None.
        Otherwise, return the source attribute.
        """
        raise NotImplementedError

    @classmethod
    def is_concrete(cls) -> bool:
        raise NotImplementedError

    def check_req(self) -> bool:
        for param in self.required_params:
            if not param.inited:
                return False
        return True

    def add_child(self, child: Optional['PlanNode']):
        self.children.append(child)
        return self

    def get_child_index_by_rel(self, rel: Relation) -> int:
        rels = self.params[BaseParam.Kind.REL]
        for i, r in enumerate(rels):
            if r == rel:
                return i
        raise ValueError(f"rel: {rel} not found in {self}")

    def __str__(self):
        param_str_list = []
        for kind, params in self.params.items():
            s = ','.join(repr(p) for p in params)
            param_str_list.append(s)
        return f"{self.name}({','.join(param_str_list)})"

    def __repr__(self):
        # return f"{str(self)}({self.str_})"
        param_str_list = []
        for kind, params in self.params.items():
            s = ','.join(repr(p) for p in params)
            param_str_list.append(s)
        return f"{self.name}({','.join(param_str_list)})"

    def copy_tree(self, with_param: bool = True):
        node = self.copy(with_param)
        node.children = [c.copy_tree(with_param) if c is not None else None for c in self.children]
        return node

    def copy(self, with_param: bool = True):
        clone = self.__class__()
        clone.assign_from(self)
        if with_param:
            for kind, params in self.params.items():
                clone_params: list[BaseParam] = clone.params.get(kind)
                for clone_param, param in zip(clone_params, params):
                    clone_param.init_from(param)
        return clone

    def mk_tree(self, match: 'PlanMatch', with_param: bool = True):
        """ Make a new tree with the same structure. A concrete node is created for each node if it is a pattern. """
        node = self.mk(match, with_param)
        node.children = [c.mk_tree(match, with_param) if c is not None else None for c in self.children]
        return node

    def mk(self, match: 'PlanMatch', with_param: bool = True):
        if self.is_concrete():
            clone = self.__class__()
        else:
            assert self.bound_src is not None
            real_bound_src = match.get_target_node(self.bound_src)
            clone = real_bound_src.__class__()
        clone.assign_from(self)
        if with_param:
            for kind, params in self.params.items():
                clone_params: list[BaseParam] = clone.params.get(kind)
                for clone_param, param in zip(clone_params, params):
                    clone_param.init_from(param)
        return clone

    def fast_equals(self, other: 'PlanNode') -> bool:
        if not isinstance(other, PlanNode):
            return False
        return self.addr == other.addr

    def semantically_equals(self, other: 'PlanNode') -> bool:
        if not isinstance(other, PlanNode):
            return False
        # same type of operator
        if self.name != other.name:
            return False
        # same kinds of params
        if self.params.keys() != other.params.keys():
            return False
        for kind, params in self.params.items():
            if kind == BaseParam.Kind.REL:
                continue
            other_params = other.params.get(kind)       # is not None
            for param1, param2 in zip(params, other_params):
                if not param1.semantically_equals(param2):
                    param1.semantically_equals(param2)
                    return False
        return True

    def dump(self):
        return {
            'vid': self.vid,
            'name': self.name,
            # 'str': self.str_,
            'str': str(self) + '\n' + (self.str_ if self.str_ is not None else '<empty str>'),
            'clazz': self.clazz,
            'addr': self.addr,
            'params': self.dump_params(),
            'children': [c.vid for c in self.children],
        }

    def dump_params(self) -> list[tuple[str, list[Any]]]:
        param_str = self.str_.split(' ', 1)[-1]
        return [('param', [param_str])]

    def get_param_name(self, param: Any) -> Optional[str]:
        raise NotImplementedError

    def build_eq_links(self, eq_node: 'PlanNode') -> list['TransLink']:
        raise NotImplementedError

    def to_tree_repr(self):
        return self.to_tree_str(repr)

    def reassign_vid(self):
        counter = IdCounter()

        def _reassign(node: PlanNode):
            node.vid = counter.get()
            for child in node.children:
                if child is not None:
                    _reassign(child)

        _reassign(self)

    # pattern matching

    def exclude(self, clz: Type['PlanNode']) -> 'PlanNode':
        self.exclusions.add(clz)
        return self

    def bind(self, src: 'PlanNode') -> 'PlanNode':
        """ This node has a same type of operator with the src node. """
        self.bound_src = src
        return self

    def match(self, other: 'PlanNode') -> bool:
        # disable the logic for CustomOp
        # from trans.plan.operator.custom_op import CustomOp
        # if issubclass(other.__class__, CustomOp) or issubclass(self.__class__, CustomOp):
        #     return self.name == other.name
        # # we cannot import CustomOp here, so use __class__.__name__
        # if self.__class__.__name__ == 'CustomOp' or other.__class__.__name__ == 'CustomOp':
        #     return self.name == other.name
        # issubclass includes self.__class__ == other.__class__
        return issubclass(other.__class__, self.__class__) and other.__class__ not in self.exclusions

    @classmethod
    def get_all_concrete_subclass(cls) -> list[Type['PlanNode']]:
        concrete_subclasses = []

        def _collect_concrete_subclass(_clz: Type['PlanNode']):
            if _clz.is_concrete():
                concrete_subclasses.append(_clz)
            else:
                for subclass in _clz.__subclasses__():
                    _collect_concrete_subclass(subclass)

        _collect_concrete_subclass(cls)
        return concrete_subclasses
